* Original public todo.org

- Read "On Bullshit" "spoken word" as "performance art".
- Write an essay/book "On Money". inspired by "On Bullshit" and "On Assholes"
- Convert the [[http://tldp.org/LDP/abs/html/string-manipulation.html][horrors of Bash]] to the wonders of Turtle Haskell

- Buy a piano / keyboard
  - Baby grand?
  - Digital piano?
  - Who was the guy from the Canberra Hotel?
    - What had he recommended? I think it was a digital baby grand. but which brand?
      - Yamaha Clavinova?
    - Be good to get lessons from him.

- Buy semi-acoustic Ovation like Scotty's old guitar.
  - Marshall amp? :-)

- Thoughtworks retropective
  - Rails is a ghetto
    - http://harmful.cat-v.org/software/ruby/rails/is-a-ghetto
    - http://web.archive.org/web/20080103072111/http://www.zedshaw.com/rants/rails_is_a_ghetto.html


 
* from private repo at Bitbucket.org/steshaw/notes


** From docs/todo.txt

  - Sell ADC shares. Carry forward huge capital loss on tax.

  - Collect "lost" super into AustralianSuper.


** Build "courseware" (aka course notes/slides):
  - Advanced Functional Programming
  - Dependently Typed Functional Programming (with Idris)
  - Compilers (for Functional Programming Languages)
  - Higher Type Theory (aka H[o]TT)

- Brian Sullivan's Haskell course (Stanford CS240. http://www.scs.stanford.edu/14sp-cs240h/)

- schemey - Write yourself a Scheme (in Haskell)

- Holy Haskell Project Starter (tutorial on project setup and cabal)

- Yesod Tutorial

- Web frameworks in Haskell.
  - Try out Scotty, Spock, Yesod, Snap.
    - http://www.yesodweb.com/book/yesod-for-haskellers
  - Write a REST/JSON client in Haskell (Twitter/GitHub client, say).
  - Write a REST/JSON server in Haskell.
  - Write a "sessionless" web app in Haskell.

- Build pi-forall

- Understand/Demystify "Auto in Agda"


- argonaut-hs
  - Use TH to auto-generate encode/decode instances.

- Swift parser for Haskell
  - language-swift-quote

- Prove that total languages can safely use fusion (because they can evaluated non-strictly).

- Design and implement a Systems Programming Languages suitable for gamedev.

- Port otcc to Idris / F* / Haskell.

- Demystifying Compilers (aka course notes/slides for Compilers course)
  - blog series to replace "Let's write a compiler"
  - "The essense of compilation" compiling a simple language in the smallest possible compiler.
    (inspired by http://www.timphilipwilliams.com/posts/2014-05-22-the-essence-of-compilation.html)
  - skeleton
    - Introduction to language design with the Simple Programming Language (SPL) â€” or perhaps call it Baby ML.
    - Lexing
    - Parsing
    - Semantic Analysis (Type Checking)
    - Simple IL/IR generation
    - Backend
      - Simple IL interpreter/engine + runtime.
      - Compile to x86_64.
      - Compile to JS.
      - Compile to JVM.
      - Compile to CLR/CLI.

- Demystifying Programming Languages

- Demystifying Dependent Types (aka course notes/slides for Dependent Types course)

- Demystifying Automated Deduction (aka course notes/slides for Automated Deduction)
  - The theorem prover from ML for the Working Programmer.
  - Djinn walkthrough.

- Demystifying Proof Assistants
  - Introduction to Coq.
  - Introduction to Agda.
  - Introduction to Isabelle.
  - Introduction to Twelf.

- Nix or Package all the things
  - Nix for your dotfiles.
  - Nix for your development environment configuration.
  - Nix for your own tools (aka etools at Ephox).
  - Nix for your (proprietary) software products.


** Soft side

- Constantly Winning OR Continuous Wins OR Why you need to stop sprinting OR Software products, a revolution from batch to real time.

