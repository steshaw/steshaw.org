
- Read some [[https://wiki.haskell.org/Research_papers/Functional_pearls][Functional Pearls]]

** Continue with PFPL.
  - [ ] Implement Abstract Binding Trees (in Idris?).
    - http://semantic-domain.blogspot.com.au/2015/03/abstract-binding-trees.html
    - http://semantic-domain.blogspot.com.au/2015/03/abstract-binding-trees-addendum.html
- Dig up my version of Simply Easy[ier].
  - https://github.com/freebroccolo/dtlc.rs

** Write an efficient nanopass compiler.
  - https://github.com/sellout/recursion-scheme-talk/blob/master/nanopass-compiler-talk.org

** Do some pipes programming
  - https://ocharles.org.uk/talks/2013-09-18-pipes.pdf
  - https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/Pipes%20tutorial

** Strict / non-strict
  - strict/cbv (with at least optional call-by-name) v non-strict/lazy/cb-need
  - with stream transducers, generators (Simple Generators), pipes, conduits, machines, iteratees, Clojures's transducers/reducers etc for stream processing. These work well with strict languages.
    - https://dl.dropboxusercontent.com/u/4588997/Machines.pdf
  - with delimited control for (tree) search.
    - http://okmij.org/ftp/continuations/#reify-search
    - tree search was the defining reason from John Huges Why FP Matters IIRC.
  - it's all delimited control.
  - perhaps we don't need laziness even for modular list/collection methods mentioned by Lennart Augustsson.
#+begin_src
  any :: (a -> Bool) -> [a] -> Bool
  any p = or . map p
#+end_src
  - take a look at the point of laziness article by Robert Harper.
  - scan FPiS for uses of laziness or call-by-name.
  - Implement this stuff in Idris and/or Scala to try it out.
  - CBPV? http://math.andrej.com/2008/11/23/a-toy-call-by-push-value-language/

** Effects
  - implement monad transformers
  - take a look at algebraic effects.
  - Idris 
    - https://eb.host.cs.st-andrews.ac.uk/drafts/effects.pdf
  - PureScript.
    - http://www.purescript.org/learn/eff/
  - Eff
    - http://www.eff-lang.org
  - Frank.
    - https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/
    - http://homepages.inf.ed.ac.uk/slindley/papers/frankly-draft-march2014.pdf
  - Koka

** Contribute to intellij-scala
  - http://blog.jetbrains.com/scala/2016/04/21/how-to-contribute-to-intellij-scala-plugin/

** Web frameworks in Haskell.
  - Try out Scotty, Spock, Yesod, Snap, Servant.
    - http://www.yesodweb.com/book/yesod-for-haskellers
  - Write a REST/JSON client in Haskell (Twitter/GitHub client, say).
  - Write a REST/JSON server in Haskell.
  - Write a "sessionless" web app in Haskell.

- Convert the [[http://tldp.org/LDP/abs/html/string-manipulation.html][horrors of Bash]] to the wonders of Turtle Haskell

- Understand/Demystify "Auto in Agda"

- Swift parser for Haskell
  - language-swift-quote

- argonaut-hs
  - Use TH to auto-generate encode/decode instances.

- Prove that total languages can safely use fusion (because they can evaluated non-strictly).

- Port otcc to Idris / F* / Haskell.

- Write notes/slides/courseware for
  - Advanced Functional Programming
  - Dependently Typed Functional Programming (with Idris)
  - Compilers (for Functional Programming Languages)
  - Type Theory including Higher Type Theory (aka H[o]TT)

** Demystifying Compilers 
  - aka course notes/slides/courseware.
  - blog series to replace "Let's write a compiler"
  - "The essense of compilation" compiling a simple language in the smallest possible compiler.
    (inspired by http://www.timphilipwilliams.com/posts/2014-05-22-the-essence-of-compilation.html)
  - skeleton
    - Introduction to language design with the BabyML.
    - Lexing/Parsing
    - Semantic Analysis (Type Checking)
    - Simple IL/IR generation
    - Backend
      - Simple IL interpreter/engine + runtime.
      - Compile to x86_64.
      - Compile to JS.
      - Compile to JVM.
      - Compile to CLR/CLI.

- Demystifying Programming Languages

- Demystifying Dependent Types 
  - aka course notes/slides for Dependent Types course

** Demystifying Automated Deduction
  - aka course notes/slides for Automated Deduction
  - The theorem prover from ML for the Working Programmer.
  - Djinn walkthrough.

** Demystifying Proof Assistants
  - Introduction to Coq.
  - Introduction to Agda.
  - Introduction to Isabelle.
  - Introduction to Twelf.

** Nix or Package all the things
  - Nix for your dotfiles.
  - Nix for your development environment configuration.
  - Nix for your own tools (aka etools at Ephox).
  - Nix for your (proprietary) software products.

** Rational Startup Movement
  - Start writing up "The Rational Startup"
    - Using Haskell for a startup.
    - rational software tooling.
    - PureScript.
    - To Scala or not to Scala, yep, that's the question.

- Port [[https://twitter.com/li_haoyi][Li Haoyi]]'s Scala-JS examples to PureScript.
  - https://gist.github.com/lihaoyi/9443f8e0ecc68d1058ad
  - Idris & Glorious GHCJS.

- Design and implement a Systems Programming Languages suitable for gamedev.

- Read "On Bullshit" "spoken word" as "performance art".

- Write an essay/book "On Money". inspired by "On Bullshit" and "On Assholes"

- Find ADC/Intec shares.
