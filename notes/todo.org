* Now

** Learn TLC Theory

*** Type Theory

- [[https://www.cis.upenn.edu/~bcpierce/sf/][Software Foundations]]

- [[http://purelytheoretical.com/sywtltt.html][So you wanna learn type theory?]]

- https://github.com/type-theory/learn-tt

*** Proof Theory

- Frank Pfennings OPLSS 2012 lecture notes on Proof Theory
  - http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/02-natded.pdf

- http://jozefg.bitbucket.org/posts/2015-02-11-proof-theory1.html

- http://math.ucsd.edu/~sbuss/ResearchWeb/handbookI/

- Proof Theory Foundations
  - https://www.cs.uoregon.edu/research/summerschool/summer14/curriculum.html
  - http://www.cs.mcgill.ca/~bpientka/oplss/
  - http://www.cs.mcgill.ca/~bpientka/oplss/book.pdf

- [[https://www.cs.uoregon.edu/research/summerschool/summer05/lectures/outline.pdf][Constructive Logic notes]] by Robert Harper, 2005 Summer School.

*** Category Theory

- Steven Awodey OPLSS 2012 lecture notes Category Theory
  - http://www.andrew.cmu.edu/user/awodey/SummerSchool/


* Next

** Demystifying Type Theory

- Explain predicative/impredicative. intensional/extensional.
- Explain variants such as UTT, OTT, CTT, CoC, CoiC, Idris TT...
- [[http://www.cs.nott.ac.uk/~psztxa/talks/constructive-06.pdf][Should Extensional Type Theory be considered harmful?]]
- Recommended by Stephanie Weirich http://plmw2014.inria.fr/talks/weirich-plmw14.pdf

  - Per Martin-Löf. Constructive mathematics and computer programming, 1982
  - Nordstrom, Petersson, and Smith. Programming in Martin-Löf's Type Theory, 1990
  - Barendregt. “Lambda Calculi with Types.” Handbook of Logic in Computer Science II, 1992
  - Harper, Honsell, Plotkin. “A Framework for Defining Logics.” JACM 1993
  - Aspinall and Hoffman. “Dependent types.” ATTAPL, 2004
  - Sørensen and Urzyczyn, Lectures on the Curry-Howard Isomorphism, 2006
  - Homotopy Type Theory: Univalent Foundations of Mathematics, 2013

- build courseware notes/articles/slides for TT/DTs course.

*** Implement Dependently Typed PL

  - Recommeded by Stephanie Weirich http://plmw2014.inria.fr/talks/weirich-plmw14.pdf. She says: "Don’t have to start from scratch"
    – Löh, McBride, Swierstra. “A Tutorial Implementation of a Dependently Typed Lambda Calculus.” Fundamenta Informa(cae, 2001
    – Lectures on implementing Idris (www.idris-lang.org)
    – My OPLSS 2013 lectures & pi-forall github repository

  - Dig up my version of Simply Easy[ier]. Do a version in Idris?
    Perhaps stick to Haskell and implement readline style repl.
    - https://github.com/freebroccolo/dtlc.rs

  - Contribute to Idris http://www.idris-lang.org/help-required/

*** Continue with PFPL

   - Implement Abstract Binding Trees (in Idris?).
     - http://semantic-domain.blogspot.com.au/2015/03/abstract-binding-trees.html
     - http://semantic-domain.blogspot.com.au/2015/03/abstract-binding-trees-addendum.html

** Read [[https://wiki.haskell.org/Research_papers/Functional_pearls][Functional Pearls]]
  - I am not a Number—I am a Free Variable. Conor McBride and James McKinna.
    - http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf 
    - http://www.strictlypositive.org/notanum.ps.gz
    - https://www.schoolofhaskell.com/user/edwardk/bound
    - http://hackage.haskell.org/package/unbound
    - https://hackage.haskell.org/package/unbound-generics
      - used in [[https://github.com/sweirich/pi-forall][pi-forall]]
    - compare with Abtract Binding Trees.
  - http://crypto.stanford.edu/~blynn/haskell/papers.html

** Learn more Coq

  - [[https://www.labri.fr/perso/casteran/CoqArt/][Coq'Art]] (again)

  - https://coq.inria.fr/tutorial/1-basic-predicate-calculus

  - https://coq.inria.fr/tutorial-nahas

  - http://www.di.ens.fr/~zappa/teaching/coq/ecole11/

  - http://adam.chlipala.net/cpdt/

  - [[http://ilyasergey.net/pnp/][Proofs and Programs]]

** Learn more Agda

- Computer Aided Formal Reasoning course at University of Nottingham
  http://www.cs.nott.ac.uk/~psztxa/g53cfr/

- [[http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Publications][Papers using Agda]]

- Understand/Demystify "Auto in Agda"

- Follow up on Conor McBride's "well founded trees".

#+BEGIN_QUOTE
jonsterling: Conor's insight is that you can define the graph of such a function as a well founded tree, and then compute by structural recursion on that tree
#+END_QUOTE

** Demystifying Module Systems

   - Start with SML and OCaml module systems.
   - expand modules reading list http://steshaw.org/plt/modules
   - [[http://caml.inria.fr/pub/papers/xleroy-modular_modules-jfp.pdf][A modular module system]], Xavier Leroy
   - https://www.mpi-sws.org/~rossberg/f-ing/
   - https://www.mpi-sws.org/%7Erossberg/1ml/
   - Does [[https://www.mpi-sws.org/~rossberg/mixml/][MixML]] go too far? i.e. is it principled?
   - Common extensions 
     - separate compilation
     - first class modules
     - recursive modules

*** Modules and Dependently Typed Languages
  - Agda/Coq/Cayenne
  - [[http://fsl.cs.illinois.edu/images/5/5e/Cayenne.pdf][Cayenne - a language with dependent types]]
  - Can dependent records do (like in Cayenne)?
    - surely dependended records don't help with separate compilation.
  - Agda seems to have a simple module system. See [[http://www.cse.chalmers.se/~ulfn/talks/modules-061220.pdf][these slides]].
    #+begin_quote
    You don’t need a fancy module system ... and you tell me why I’m wrong.
    #+end_quote

*** Relationship with Type Classes
  - read modular type classes (MTC) in http://steshaw.org/plt/modules
  - Kmett's type classes versus the world. i.e. global uniqueness of
    type classes. Kmett says he wants both type classes and an ML
    style module system.
  - Investigate modules/type-classes in Agda/Coq/Cayenne.

** Demystifying Datatype Generic Programming
  - polytypic programming or whatevers
  - [[http://itu.dk/people/asal/pubs/msc-thesis-report.pdf][The Practical Guide to Levitation]], Ahmad Salim Al-Sibahi M.Sc. Thesis
    - https://github.com/ahmadsalim/MSc-Thesis
  - [[https://personal.cis.strath.ac.uk/conor.mcbride/levitation.pdf][Gentle Art of Levitation]]
  - SYB
  - GHC.Generic - why do people not like this
  - uniplate etc.
  - how does this apply in a dependently typed setting?
  - http://www.andres-loeh.de/ExploringGH.pdf
  - Talk from Andres Löh
    - http://skillsmatter.com/podcast/home/a-haskell-lecture-with-leading-expert-andres-loh
    - http://www.andres-loeh.de/GP-ITB.pdf
  - add datatype generic programming section to PLT website.
  - [[http://dreixel.net/research/pdf/gpif.pdf][Generic Programming with Indexed Functors]], Andres Löh, José Pedro Magalhães
    - port to Idris https://github.com/pbl64k/gpif-idris
  - Andres recommends generics-sop these days. Introduction at https://github.com/kosmikus/SSGEP.

** Demystifying Homotopy Type Theory

- https://homotopytypetheory.org/book/
- https://www.cs.cmu.edu/~rwh/courses/hott/

*** Category Theory

- Dominic Verity introductory talks
  - [[https://vimeo.com/17207564][Part 1]]
  - [[https://youtu.be/yilkBvVDB_w][Part 2]]

*** Categorical Logic

- http://www.cs.man.ac.uk/~pt/Practical-Foundations/html/index.html
- https://ncatlab.org/nlab/show/Sheaves+in+Geometry+and+Logic
- https://www.andrew.cmu.edu/user/awodey/catlog/notes/
- http://www.mathematik.tu-darmstadt.de/~streicher/CTCL.pdf
- [[http://www.mpi-sws.org/~dreyer/courses/catlogic/jacobs.pdf][Categorical Logic and Type Theory]]
- [[http://www.edsko.net/tcd/talks/cattheory.pdf][Abstract nonsense for Functional Programmers]]

*** Topos

- [[https://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories-ebook/dp/B00AKE1VFE?ie=UTF8&me=&ref_=mt_kindle][Conceptual Mathematics]]
- [[http://arxiv.org/pdf/1012.5647v3.pdf][An information introduction to Topos theory]]
- https://ncatlab.org/nlab/show/topos
- http://www.staff.science.uu.nl/~ooste110/syllabi/toposmoeder.pdf
- [[http://math.ucr.edu/home/baez/topos.html][Topos Theory in a Nutshell]]

** Functional Programming in Scala

  - http://eed3si9n.com/learning-scalaz/

*** Contribute to intellij-scala
   - http://blog.jetbrains.com/scala/2016/04/21/how-to-contribute-to-intellij-scala-plugin/

** Focusing

  - https://www.cs.cmu.edu/~fp/courses/oregon-m10/04-focusing.pdf
  - https://www.cs.cmu.edu/~fp/courses/15816-s12/lectures/09-focusing.pdf

** Write an efficient nanopass compiler.
  - https://github.com/sellout/recursion-scheme-talk/blob/master/nanopass-compiler-talk.org

** Learn pipes

  - https://ocharles.org.uk/talks/2013-09-18-pipes.pdf
  - https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/Pipes%20tutorial

** Investigate strict v non-strict
  - strict/cbv (with at least optional call-by-name) v non-strict/lazy/cb-need
  - with stream transducers, generators (Simple Generators), pipes, conduits, machines, iteratees, Clojures's transducers/reducers etc for stream processing. These work well with strict languages.
    - https://dl.dropboxusercontent.com/u/4588997/Machines.pdf
  - with delimited control for (tree) search.
    - http://okmij.org/ftp/continuations/#reify-search
    - tree search was the defining reason from John Huges Why FP Matters IIRC.
    - isSubstringOf x y = any (isPrefixOf x) (tails y)
      - Cale Gibbard
      - http://lambda-the-ultimate.org/node/1277#comment-14313
      - Noted in FPiS
  - it's all delimited control.
  - perhaps we don't need laziness even for modular list/collection methods mentioned by Lennart Augustsson.
    - http://augustss.blogspot.com.au/2011/05/more-points-for-lazy-evaluation-in.html
#+BEGIN_SRC
  any :: (a -> Bool) -> [a] -> Bool
  any p = or . map p
#+END_SRC
  - take a look at the point of laziness article by Robert Harper.
  - scan FPiS for uses of laziness or call-by-name.
  - Implement this stuff in Idris and/or Scala to try it out.
  - CBPV? http://math.andrej.com/2008/11/23/a-toy-call-by-push-value-language/

** Effects
  - implement monad transformers
  - take a look at algebraic effects.
  - Idris 
    - https://eb.host.cs.st-andrews.ac.uk/drafts/effects.pdf
  - PureScript.
    - http://www.purescript.org/learn/eff/
  - Eff
    - http://www.eff-lang.org
  - Frank.
    - https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/
    - http://homepages.inf.ed.ac.uk/slindley/papers/frankly-draft-march2014.pdf
  - Koka

** Haskell

- argonaut-hs
  - Use TH to auto-generate encode/decode instances.

- Prove that total languages can safely use fusion (because they can evaluated non-strictly).

- Port otcc to Idris/Haskell.

*** Swift parser for Haskell

- sigh
- language-swift-quote

*** Turtle

- Convert the [[http://tldp.org/LDP/abs/html/string-manipulation.html][horrors of Bash]] to the wonders of Turtle Haskell

*** Web frameworks in Haskell.
   - Try out Scotty, Spock, Yesod, Snap, Servant.
     - http://www.yesodweb.com/book/yesod-for-haskellers
   - Write a REST/JSON client in Haskell (Twitter/GitHub client, say).
   - Write a REST/JSON server in Haskell.
   - Write a "sessionless" web app in Haskell.

** Demystifying Advanced Functional Programming
  - recursion schemes
  - Algebra of Programming.
  - notes/slides/courseware on advanced FP techniques

** Demystifying Dependently Typed Functional Programming with Idris

- Read [[https://www.manning.com/books/type-driven-development-with-idris][Type-Driven Development with Idris]], by Edwin Brady.
- Contribute to Idris.
- Courseware: notes/articles/slides.

** Demystifying Compilers 
  - aka course notes/slides/courseware.
  - blog series to replace "Let's write a compiler"
  - http://jozefg.bitbucket.org/posts/2015-03-24-pcf.html
  - "The essense of compilation" compiling a simple language in the smallest possible compiler.
    (inspired by http://www.timphilipwilliams.com/posts/2014-05-22-the-essence-of-compilation.html)
  - skeleton
    - Introduction to language design with the BabyML.
    - Lexing/Parsing
    - Semantic Analysis (Type Checking)
    - Simple IL/IR generation
    - Backend
      - Simple IL interpreter/engine + runtime.
      - Compile to x86-64.
      - Compile to JS.
      - Compile to JVM.
      - Compile to CLR/CLI.

** Demystifying Automated Deduction
  - aka course notes/slides for Automated Deduction
  - The theorem prover from ML for the Working Programmer.
  - Djinn walkthrough.

** Demystifying Proof Assistants
  - Introduction to Coq.
  - Introduction to Agda.
  - Introduction to Isabelle.
  - Introduction to Twelf.

** Nix or Package all the things

  - Nix for your dotfiles.
  - Nix for your development environment configuration.
  - Nix for your own tools (aka etools at Ephox).
  - Nix for your (proprietary) software products.

** Rational Startup Movement
  - Start writing up "The Rational Startup"
    - Using Haskell for a startup.
    - rational software tooling.
    - PureScript.
    - To Scala or not to Scala, yep, that's the question.

** PureScript

- Port [[https://twitter.com/li_haoyi][Li Haoyi]]'s Scala-JS examples to PureScript.
  - https://gist.github.com/lihaoyi/9443f8e0ecc68d1058ad
  - Idris & Glorious GHCJS.

** Learn LaTex

- Produce something (tech report?) with LaTeX. Perhaps via org-mode.

** Logic Programming

- [[http://people.cs.uchicago.edu/~odonnell/Scholar/Technical_papers/Intro_Logic_Prog/description.html][Logic and Logic Programming]]

** PL suitable for gamedev

- Design and implement a Systems Programming Languages suitable for gamedev.
- Gamedev's would probably be super happy with Rust...

** Misc

- Read "On Bullshit" "spoken word" as "performance art".

- Write an essay/book "On Money". inspired by "On Bullshit" and "On Assholes"

- Find ADC/Intec shares.
