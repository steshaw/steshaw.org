* Todo Now

  - [-] PFPL (book). OPLSS 2016 chapters 1-10, 14-20, 37-38, 46-48.
    - [X] I Judgements and Rules
      - [X] 1 Abstract Syntax
      - [X] 2 Inductive Definitions
      - [X] 3 Hypothetical and General Judgements
    - [X] II Statics and Dynamics
      - [X] 4 Statics
      - [X] 5 Dynamics
      - [X] 6 Type Safety
      - [X] 7 Evaluation Dynamics
    - [ ] III Total Functions
      - [ ] 8 Function Definitions and Values
      - [ ] 9 System T of Higher-Order Recursion
    - [ ] IV Finite Data Types
      - [ ] 10 Product Types
      - [ ] 11 Sum Types
    - [ ] V Types and Propositions
      - [ ] 12 Constructive Logic
      - [ ] 13 Classical Logic
    - [ ] VI Infinite Data Types
      - [ ] 14 Generic Programming
      - [ ] 15 Inductive and Coinductive Types
    - [ ] VII Variable Types
      - [ ] 16 System F of Polymorphic Types
      - [ ] 17 Abstract Types
      - [ ] 18 Higher Kinds
    - [ ] VIII Partiality and Recursive Types
      - [ ] 19 System PCF of Recursive Functions
      - [ ] 20 System FPC of Recursive Types
    - [ ] IX Dynamic Types
      - [ ] 21 The Untyped λ-Calculus
      - [ ] 22 Dynamic Typing
      - [ ] 23 Hybrid Typing
    - [ ] X Subtyping
      - [ ] 24 Structual Subtyping
      - [ ] 25 Behavioural Subtyping
    - [ ] XI Dynamic Dispatch
      - [ ] 26 Classes and Methods
      - [ ] 27 Inheritance
    - [ ] XII Control Flow
      - [ ] 28 Control Stacks
      - [ ] 29 Exceptions
      - [ ] 30 Continuations
    - [ ] XIII Symbolic Data
      - [ ] 31 Symbols
      - [ ] 32 Fluid Binding
      - [ ] 33 Dynamic Classification
    - [ ] XIV Mutable State
      - [ ] 34 Modernized Algol
      - [ ] 35 Assignable References
      - [ ] 36 Lazy Evaluation
    - [ ] XV Parallelism
      - [ ] 37 Nested Parallelism
      - [ ] 38 Futures and Speculations
    - [ ] XVI Concurrency and Distribution
      - [ ] 39 Process Calculus
      - [ ] 40 Concurrent Algol
      - [ ] 41 Distributed Algol
    - [ ] XVII Modularity
      - [ ] 42 Modularity and Linking
      - [ ] 43 Singleton Kinds and Subkinding
      - [ ] 44 Type Abstraction and Type Classes
      - [ ] 45 Heirarchy and Parameterization
    - [ ] XVIII Equational Reasoning
      - [ ] 46 Equality for System T
      - [ ] 47 Equality for System PCF
      - [ ] 48 Parametricty
      - [ ] 49 Process Equivalence
    - [ ] XIX Equational Reasoning
      - [ ] A Background on Finite Sets

  - [[https://www.cis.upenn.edu/~bcpierce/sf/][Software Foundations]] (book)
    - at =Equiv.v=, =assign_aequiv=.

  - [-] [[https://www.manning.com/books/type-driven-development-with-idris][Type-Driven Development with Idris]], by Edwin Brady (book).
    - [X] Chapter 1
    - [ ] Chapter 2
    - [ ] Chapter 3

  - [-] [[https://www.coursera.org/learn/learning-how-to-learn/home/welcome][Learning How to Learn]] (Coursera Course)
    - [X] [[https://www.coursera.org/learn/learning-how-to-learn/home/week/1][Week 1 -- What is learning?]]
    - [X] [[https://www.coursera.org/learn/learning-how-to-learn/home/week/2][Week 2 -- Chunking]]
    - [X] [[https://www.coursera.org/learn/learning-how-to-learn/home/week/3][Week 3 -- Procrastination and Memory]]
    - [ ] [[https://www.coursera.org/learn/learning-how-to-learn/home/week/4][Week 4 -- Renaissance Learning]]

** So you wanna learn Type Theory

  - [-] [[http://purelytheoretical.com/sywtltt.html][So you wanna learn type theory?]]
    - [X] Watch Frank Pfenning's [[https://www.youtube.com/playlist?list=PL_zaeQ6Mf5FAYNk3GsK9tdj_Ce-eIfH_b][OPLSS-2012 lectures "Proof Theory Foundations"]].
    - [ ] Read [[http://purelytheoretical.com/papers/ATCHC.pdf][A Tutorial on the Curry-Howard Correspondence]] by Darryl McAdams.
    - [-] Read Frank Pfenning's [[http://www.cs.cmu.edu/~fp/courses/15317-f09/schedule.html][course notes on Constructive Logic]].
      - [X] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/01-overview.html][Lecture 1: Overview]]
      - [X] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/02-natded.html][Lecture 2: Natural Deduction]]
      - [X] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/03-harmony.html][Lecture 3: Harmony]]
      - [X] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/04-pap.html][Lecture 4: Proofs as Programs]]
      - [X] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/05-quant.html][Lecture 5: Quantification]]
      - [X] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/06-nat.html][Lecture 6: Natural Numbers]]
      - [ ] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/07-classical.html][Lecture 7: Classical Logic]]
      - [ ] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/08-classical-programs.html][Lecture 8: Classical Computation]]
      - [ ] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/09-seqcalc.html][Lecture 9: Sequent Calculus]]
      - [ ] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/10-cutelim.html][Lecture 10: Cut Elimination]]
      - [ ] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/11-inversion.html][Lecture 11: Inversion]]
      - [ ] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/12-proving.html][Lecture 12: Propositional Theorem Proving]]
      - [ ] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/13-lp.html][Lecture 13: Logic Programming]]
      - [ ] [[http://www.cs.cmu.edu/~fp/courses/15317-f09/lectures/14-prolog.html][Lecture 14: Prolog]]
    - [X] Watch Bob Harper's [[https://www.youtube.com/playlist?list=PLGCr8P_YncjXRzdGq2SjKv5F2J8HUFeqN][OPLSS-2012 lectures "Type Theory Foundations"]].
    - [-] Read [[http://www.cse.chalmers.se/research/group/logic/book/book.pdf][Programming in Martin-Löf Type Theory]].
      - [X] 1 Introduction
      - [X] 2 The identification of sets, propositions and specifications
      - [X] 3 Expressions and definitional equality
      - [-] I Polymorphic sets
        - [X] 4 The semantics of the judgement forms
        - [X] 5 General rules
	- [ ] 6 Enumeration sets
	- [ ] 7 Cartesian product of a family of sets
	- [ ] 8 Equality sets
	- [ ] 9 Natural numbers
	- [ ] 10 Lists
	- [ ] 11 Cartesian product of two sets
	- [ ] 12 Disjoint union of two sets
	- [ ] 13 Disjoint union of a family of sets
	- [ ] 14 The set of small sets (The first universe)
	- [ ] 15 Well-orderings
	- [ ] 16 General trees
      - [ ] II Subsets
	- [ ] 17 Subsets in the basic set theory
	- [ ] 18 The subset theory
      - [ ] III Monomorphic sets
	- [ ] 19 Types
	- [ ] 20 Defining sets in terms of types
      - [ ] IV Examples
	- [ ] 21 Some small examples
	- [ ] 22 Program derivation
	- [ ] 23 Specification of abstract data types
      - [ ] A Constants and their arities
      - [ ] B Operational semantics

* Todo Next

** Demystifying Idris

  - [ ] MiniCaml
    - https://github.com/lambdataro/zam-test looks to have OCaml
      MiniCaml and ZAM.
  - [ ] Implement a number of simple TT/PLs in Idris/ML (perhaps from TAPL).
    - [[http://ozark.hendrix.edu/~yorgey/490/][STLC in Idris]] and more (course notes by Brent Yorgey).
  - [-] idris-miniml
    - [X] idris-miniml port of plzoo/miniml
    - [ ] Extend with ideas from [[http://ucsd-progsys.github.io/cse130/homeworks/hw4.html][CSE130's NanoML]].
    - https://github.com/hanazuki/miniml (OCaml)
    - https://github.com/cadesalaberry/ocaml-practice/tree/master/hw5 (OCaml)
    - https://github.com/pierthodo/Mini-ML (OCaml)
    - https://github.com/timcolonel/socs/tree/master/Comp%20302/hw5/mini-ml (SML)
    - https://github.com/bitonic/ml-w (Haskell)
    - Coq verification of a MiniML https://github.com/coq-contribs/miniml
    - Very interesting looking verified [[http://www.cl.cam.ac.uk/~mom22/miniml/][mini-ml]].
  - [ ] [[https://github.com/steshaw/babyml][BabyML]] in Idris.
    - Haskellish syntax. Type applications. Function signatures.
    - MLish with D-H-M type inference / unification.
    - [[http://steshaw.org/hm/][Ian Grant's Hindly-Milner tutorial]]
  - MinCaml "port"
    - [[https://esumii.github.io/min-caml/index-e.html][Min-Caml (website)]] [[https://esumii.github.io/min-caml/paper.pdf][paper]]
    - Would like to see nanopass ideas applied here but using
      recursion schemes rather than schemey dynamic typing.
  - [ ] Build a printf (puffnfresh has great video).
    - Other standard dependently-typed examples?
  - [ ] BabyIdris in Idris
  - [ ] Contribute to Idris.
    - [ ] Check out  Paul Körbitz's look at Idris internals:
      - [ ] [[http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-I-Overview-and-Parsing.html][Part 1]]
      - [ ] [[http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-II-Taking-the-Parser-for-a-Spin.html][Part 2]]
      - [ ] [[http://koerbitz.me/posts/A-Look-at-the-Idris-Internals-Part-III-From-Parsing-to-Elaboration.html][Part 3]]
  - [ ] [[https://gist.github.com/edwinb/46da18e2fc6be3f92177ea02ea4b3a1a][Edwin's code for merge sort]]
  - Is it possible to build total parser combinators?
    - Yes, apparently. See [[http://www.cse.chalmers.se/~nad/publications/danielsson-parser-combinators.html][Total Parser Combinators (paper)]]. This
      requires the use of dependent types as so is quite
      interesting. An undergraduate Cambridge student may be taking
      this up (overhead on #idris). Edwin Brady suggested that a total
      parser combinator library in Idris would ideally make use of the
      partial evaluator (see [[https://eb.host.cs.st-andrews.ac.uk/writings/icfp10.pdf][this paper]]).
  - An LALR/LR/LL(k) parser generator would be nice (like Happy or something).
  - Try deriving with the elaborator.
    - https://gist.github.com/david-christiansen/8c66822a471bf929a22f
    - https://github.com/david-christiansen/derive-all-the-instances
  - [[http://toss.sourceforge.net/ocaml.html][Implement the NNF of formulas tutorial]]. Looks like the same as the
    one from the tail end of ML for the Working Programmer.
  - Implement the prover from ML for the Working Programmer.
  - Courseware: notes/articles/slides.
  - [X] idris-calc port of plzoo/calc

** PL: Type Systems / Type Inference / Semantics / Design

  - [ ] TAPL (book)
  - [ ] Type systems for programming languages Didier Rémy (course notes)
    - [ ] http://pauillac.inria.fr/~remy/mpri/cours1.pdf
    - [ ] http://pauillac.inria.fr/~remy/mpri/cours2.pdf
    - [ ] http://pauillac.inria.fr/~remy/mpri/cours3.pdf
    - [ ] http://pauillac.inria.fr/~remy/mpri/cours4.pdf
    - [ ] http://pauillac.inria.fr/~remy/mpri/cours5.pdf
  - [ ] http://www.eecs.harvard.edu/~greg/cs256sp2005/
  - [ ] [[https://www.cl.cam.ac.uk/~gw104/dens.pdf][Denotational Semantics notes, Glynn Winskel]]
  - [ ] [[https://www.cis.upenn.edu/~sweirich/icfp-plmw15/][PLMW @ ICFP 2015 - The Programming Languages Mentoring Workshop]]
  - [ ] [[http://caml.inria.fr/pub/docs/u3-ocaml/][(UUU) Using, Understanding, and Unraveling The OCaml Language: From Practice to Theory and vice versa]]

*** Type Inference
  - [X] [[https://www.cis.upenn.edu/~sweirich/icfp-plmw15/slides/pottier.pdf][Type Inference (slides), François Pottier]]
  - [[http://www.cs.bham.ac.uk/~krishnan/bidir.pdf][Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism]], Joshua Dunfield, Neelakantan R. Krishnaswami
    - an implementation https://github.com/ollef/Bidirectional
    - [[http://www.cs.cmu.edu/~joshuad/talks/icfp13/Dunfield_icfp13-talk.pdf][Joshua's bidir website]]
    - [[http://www.cs.cmu.edu/~joshuad/talks/icfp13/Dunfield_icfp13-talk.pdf][slides]]
  - [[http://steshaw.org/hm/][Ian Grant's Hindly-Milner tutorial]]
  - [ ] [[http://gallium.inria.fr/~fpottier/publis/fpottier-elaboration.pdf][Hindley-Milner Elaboration in Applicative Style, Functional pearl, François Pottier]]
  - [ ] [[https://www.mpi-sws.org/~beta/papers/unicoq.pdf][A Unification Algorithm for COQ Featuring Universe Polymorphism and Overloading]] (paper)

** Demystifying Category Theory

  - Steven Awodey OPLSS 2012 lecture notes Category Theory
    - http://www.andrew.cmu.edu/user/awodey/SummerSchool/

** Demystifying Proof Theory

  - [X] http://jozefg.bitbucket.org/posts/2015-02-11-proof-theory1.html
  - [ ] [[https://www.cl.cam.ac.uk/~gw104/PLC-mini-course.pdf][Mini-course on proof theory, Pierre-Louis Curien]]
  - [ ] [[https://www.cs.uoregon.edu/research/summerschool/summer05/lectures/outline.pdf][Constructive Logic notes]] by Robert Harper, 2005 Summer School.
  - [ ] [[http://logitext.mit.edu/logitext.fcgi/tutorial][Interactive sequent calculus tutorial]]
  - [ ] [[https://avigad.github.io/logic_and_proof/][Logic and Proof]] Introduction to Lean theorem prover (via Lean.JS)
  - [ ] Proof Theory Foundations, OPLSS 2014
    - https://www.cs.uoregon.edu/research/summerschool/summer14/curriculum.html
    - http://www.cs.mcgill.ca/~bpientka/oplss/
    - http://www.cs.mcgill.ca/~bpientka/oplss/book.pdf
  - [[http://math.ucsd.edu/~sbuss/ResearchWeb/handbookI/][An Introduction to Proof Theory]], Samuel R. Buss.
  - Demystify terminology
    - propositional logic
    - predicate calculus
    - first-order intuitionistic logic
    - first order logic

** Demystifying Mathematical Logic & Logic Programming

  - Are there other interesting part of Mathematical Logic other than
    Proof Theory? Wikipedia mentions the following sub fields:
    - Set Theory
    - Model Theory
    - Recursion Theory
    - Proof Theory

  - [[http://people.cs.uchicago.edu/~odonnell/Scholar/Technical_papers/Intro_Logic_Prog/description.html][Logic and Logic Programming]]

  - [[https://www.cs.cmu.edu/~fp/papers/mdorf01.pdf][Logical Frameworks –—— A Brief Introduction]]

  - https://github.com/mietek/haskell-exchange-2015
  - https://github.com/mietek/formal-logic

  - Frank Pfennings Computation and Deduction Course and notes
    - https://www.cs.cmu.edu/~fp/courses/comp-ded/handouts.html
    - Uses Twelf

  - Velleman, How to Prove It.

** Increase Mathematical Sophistication & Demystify Mathematical Foundations

  - [[http://paultaylor.eu/~pt/prafm/html/index.html][Practical Foundations of Mathematics]], Paul Taylor.

  - for Heyting algebras
    - [[http://www.amazon.com/Introduction-Lattices-Order-B-Davey/dp/0521784514][Introduction to Lattices and Order]]
    - Category Theory by Awodey
    - [[http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf][Category Theory for Computing Science]]
    - [[http://www.math.uwaterloo.ca/~snburris/htdocs/ualg.html][A course in Universal Algebra]] [[http://www.math.uwaterloo.ca/~snburris/htdocs/UALG/univ-algebra2012.pdf][PDF]]
    - https://github.com/UniversalAlgebra/UAResources

  - HoTT book

** Demystifying Type Theory

  - [ ] Demystify terminology.
    - [ ] Demystify predicative/impredicative.
    - [ ] Demystify intensional/extensional.
    - [ ] Demystify relational parametricity.
      - [[http://cstheory.stackexchange.com/questions/19548/how-can-relational-parametricity-be-motivated][How can relational parametricity by movitated (Stackoverflow)]]
    - [ ] Demystify "logical relations" aka apparently "Tait's
      method", "the method of computability" and "realizability".
    - [ ] Demystify "parametricity".
    - [ ] Demystify "first-class polymorphism".
    - [ ] Demystify "second-class polymorphism".
    - [ ] Demystify "polymorphic recursion".
    - [ ] Demystify "universal polymorphism".
    - [ ] Demystify "existential polymorphism".
      - See [[http://lambda-the-ultimate.org/node/4865#comment-78185][Andreas Rossberg's comment(s) on Lambda the Ultimate]].
#+begin_quote
**It's second-class vs first-class that matters**

That's not quite right. You seem to be assuming that you can always statically monomorphise universal polymorphism, but that is only true if polymorphism is second-class (*). And in that case, it is just as true for existential polymorphism (e.g., some SML compilers "monomorphise" modules routinely).
As soon as you have first-class polymorphism, though (e.g., higher-ranked polymorphic types), you cannot do that anymore, neither for universal nor for existential polymorphism. Furthermore, as naasking pointed out, you can encode existentials with universals then, so there really is no difference in the degree of static knowledge.
In short, the compile time vs run time distinction does not hinge on universal vs existential polymorphism, but on second-class vs first-class polymorphism (and existentials in Haskell happen to be first-class).
(*) And in fact, not even then, as Haskell's counter-example of polymorphic recursion shows -- contrary to popular belief, type class polymorphism is not static in Haskell, not even in plain H'98. Common optimisations notwithstanding.
#+end_quote
    - [ ] Encoding existentials with universals. [[Http://lambda-the-ultimate.org/node/4865#comment-78207][See here]].
  - Explain variants such as UTT, OTT, CTT, CoC, CoiC, Idris TT...
  - [[http://www.cs.nott.ac.uk/~psztxa/talks/constructive-06.pdf][Should Extensional Type Theory be considered harmful?]]
  - http://www.cse.chalmers.se/~peterd/papers/historyidentitytype.pdf
  - Recommended by Stephanie Weirich http://plmw2014.inria.fr/talks/weirich-plmw14.pdf
    - Per Martin-Löf. Constructive mathematics and computer programming, 1982
    - Nordstrom, Petersson, and Smith. Programming in Martin-Löf's Type Theory, 1990
    - Barendregt. “Lambda Calculi with Types.” Handbook of Logic in Computer Science II, 1992
    - Harper, Honsell, Plotkin. “A Framework for Defining Logics.” JACM 1993
    - Aspinall and Hoffman. “Dependent types.” ATTAPL, 2004
    - Sørensen and Urzyczyn, Lectures on the Curry-Howard Isomorphism, 2006
    - Homotopy Type Theory: Univalent Foundations of Mathematics, 2013
  - [[https://github.com/michaelt/martin-lof][Works of Per Martin-Löf]]. Jon Sterling recommends especially: Constructive mathematics and computer programming, On the Meanings of the Logical Constants and the Justification of Logical Laws, and Intuitionistic Type Theory.
  - http://www.jonmsterling.com/pdfs/meaning-explanations.pdf

- Notes/articles/slides.
- [[http://jozefg.bitbucket.org/posts/2015-09-27-flavors.html][Two Different Flavors of Type Theory]], Danny Gratzer

*** Implement Dependently Typed PL

  - Recommeded by Stephanie Weirich http://plmw2014.inria.fr/talks/weirich-plmw14.pdf. She says: "Don’t have to start from scratch"
    – Löh, McBride, Swierstra. “A Tutorial Implementation of a Dependently Typed Lambda Calculus.” Fundamenta Informa(cae, 2001
    – Lectures on implementing Idris (www.idris-lang.org)
    – My OPLSS 2013 lectures & pi-forall github repository

  - Dig up my version of Simply Easy[ier]. Do a version in Idris?
    Perhaps stick to Haskell and implement readline style repl.
    - https://github.com/freebroccolo/dtlc.rs
  - https://github.com/jyp/nano-Agda
  - https://github.com/jyp/sctt

  - Contribute to Idris http://www.idris-lang.org/help-required/

** Read Functional Pearls
  - [[https://wiki.haskell.org/Research_papers/Functional_pearls][Functional Pearls]]
  - [ ] I am not a Number (see [[#name-binding][below]]).
  - http://crypto.stanford.edu/~blynn/haskell/papers.html
  - [ ] [[http://gallium.inria.fr/~fpottier/publis/fpottier-elaboration.pdf][Hindley-Milner Elaboration in Applicative Style, Functional pearl, François Pottier]]
  - [ ] [[https://jonathan.protzenko.fr/papers/iwil15.pdf][Functional Pearl: the Proof Search Monad]], Jonathan Protzenko

** Name binding
  - I am not a Number—I am a Free Variable. Conor McBride and James McKinna.
    - http://www.cs.ru.nl/~james/RESEARCH/haskell2004.pdf 
    - http://www.strictlypositive.org/notanum.ps.gz
  - https://www.schoolofhaskell.com/user/edwardk/bound
  - http://hackage.haskell.org/package/unbound
  - https://hackage.haskell.org/package/unbound-generics
    - used in [[https://github.com/sweirich/pi-forall][pi-forall]]
  - compare with Abtract Binding Trees.
  - https://github.com/jyp/NameBindingSurvey/blob/master/WhiteBoard.md
    - https://github.com/jyp/TTNameBinders
    - Names for free
      - https://nicolaspouillard.fr/talks/names-for-free-haskell-symposium/names-for-free.html#/
      - http://www.cse.chalmers.se/~bernardy/NamesForFree.pdf
  - Implement Abstract Binding Trees (in Idris?).
    - http://semantic-domain.blogspot.com.au/2015/03/abstract-binding-trees.html
    - http://semantic-domain.blogspot.com.au/2015/03/abstract-binding-trees-addendum.html
  - https://nicolaspouillard.fr/publis/namely-painless-defense-version.pdf
  - http://requestforlogic.blogspot.com.au/2010/11/totally-nameless-representation.html
  - [X] Namely Painless
  - [[http://winterkoninkje.dreamwidth.org/103978.html][Well-typed ABTs]]

** Demystifying Coq

  - [[https://www.labri.fr/perso/casteran/CoqArt/][Coq'Art]] (again)

  - https://coq.inria.fr/tutorial/1-basic-predicate-calculus

  - https://coq.inria.fr/tutorial-nahas

  - http://www.di.ens.fr/~zappa/teaching/coq/ecole11/

  - http://adam.chlipala.net/cpdt/

  - [[http://ilyasergey.net/pnp/][Proofs and Programs]]

** Demystifying Agda

  - Computer Aided Formal Reasoning course at University of Nottingham
    http://www.cs.nott.ac.uk/~psztxa/g53cfr/
  - [[http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Publications][Papers using Agda]]
  - http://people.inf.elte.hu/divip/AgdaTutorial/Index.html
  - http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.Othertutorials
  - Understand/Demystify "Auto in Agda"
  - Follow up on Conor McBride's "well founded trees".
  - Peter Dybjer's lectures from [[https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html][OPLSS 2015]]
    His notes http://www.cse.chalmers.se/~peterd/papers/oplss15.html
  - [[http://www.cl.cam.ac.uk/~ok259/agda-course-13/][Dependently typed metaprogramming (in Agda)]] course by Conor McBride
  - http://oxij.org/note/BrutalDepTypes/
  - Conor's notes from [[https://www.cs.ox.ac.uk/projects/utgp/school/notes.html][Summer School on Generic and Effectful Programming 2015]]
    - https://github.com/pigworker/SSGEP-datadata
    - https://www.cs.ox.ac.uk/projects/utgp/school/conor.pdf

#+BEGIN_QUOTE
jonsterling: Conor's insight is that you can define the graph of such a function as a well founded tree, and then compute by structural recursion on that tree
#+END_QUOTE

** Demystifying Module Systems

   - Start with SML and OCaml module systems.
     - http://jozefg.bitbucket.org/posts/2015-01-08-modules.html
     - [[http://stackoverflow.com/questions/15584848/whats-the-difference-if-any-between-standard-mls-module-system-and-ocaml-mod][Rossberg on SML OCaml module systems (StackOverflow)]]
   - Expand/revise modules reading list http://steshaw.org/plt/modules
     - [X] [[http://gallium.inria.fr/~xleroy/bibrefs/Leroy-modular-modules.html][A modular module system]], Xavier Leroy
     - [[http://www.mpi-sws.org/~skilpat/modsem/][Type Systems for Modules (Winter 2010)]] course by Derek Dreyer
     - [[https://web.archive.org/web/20110910021609/http://www.cs.cmu.edu/~rwh/courses/modules/][Bob Harper's Modules courses]] (from archive.org)
     - https://www.mpi-sws.org/~rossberg/f-ing/
     - https://www.mpi-sws.org/%7Erossberg/1ml/ ([[http://lambda-the-ultimate.org/node/5121][LtU commentary]])
     - Does [[https://www.mpi-sws.org/~rossberg/mixml/][MixML]] go too far? i.e. is it "principled"?
       - You end up with initialisation ordering issues like in OOP.
   - Common extensions
     - separate compilation
     - first class modules
     - recursive modules (seemingly the most difficult)
   - [[https://wiki.mpi-sws.org/star/paramore][Parametricity and Modular Reasoning]] course by Derek Dreyer.
   - [[http://www.cis.upenn.edu/~bcpierce/papers/modules-icfp.ps][Advanced Module Systems - a guide for the perplexed]] Dreyer and Harper.
   - [[http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/24/slides/derek.pdf][Why Applicator Functors Matter]]
   - http://www.ccs.neu.edu/home/amal/course/7480-s12/modules-notes.pdf
   - OCaml course at Cornell
     - [[http://www.cs.cornell.edu/courses/cs3110/2015fa/][cs3110/2015fa]] pretty
     - [[http://www.cs.cornell.edu/courses/cs3110/2016sp/lecture_notes.php][cs3110/2016sp]] more type theory
   - Rossberg's SML and sML (successor ML) implementations.
     - http://www.mpi-sws.org/~rossberg/hamlet/
     - http://www.mpi-sws.org/~rossberg/hamlet/#successor-ml
   - [[https://github.com/kfl/mosml][Moscow ML]] with a simple runtime based on caml-light.
   - Pros and Cons of modules
     - [[http://lambda-the-ultimate.org/node/4865#comment-78074][Some comments from Andreas Rossberg on LtU]]

*** Modules and Dependently Typed Languages
  - Agda/Coq/Cayenne
  - [[http://fsl.cs.illinois.edu/images/5/5e/Cayenne.pdf][Cayenne - a language with dependent types]]
  - Can dependent records do (like in Cayenne)?
    - surely dependended records don't help with separate compilation.
  - Agda seems to have a simple module system. See [[http://www.cse.chalmers.se/~ulfn/talks/modules-061220.pdf][these slides]].
    #+begin_quote
    You don’t need a fancy module system ... and you tell me why I’m wrong.
    #+end_quote

*** Relationship with Type Classes
  - read modular type classes (MTC) in http://steshaw.org/plt/modules.
    - Update with "modular implicits" in OCaml.
    - The work of Bruno C. d. S. Oliverira
      - [[http://www.cs.ox.ac.uk/people/bruno.oliveira/objects.pdf][Objects to Unify Type Classes and GADTs]] with Martin Sulzmann.
      - [[https://infoscience.epfl.ch/record/150280/files/TypeClasses.pdf][Type Classes as Objects and Implicits]] with Adriaan Moors and
        Martin Odersky.
      - [[http://homepages.inf.ed.ac.uk/wadler/papers/implicits/implicits.pdf][The Implicit Calculus: A New Foundation for Generic
        Programming]] with Tom Schrijvers, Wontae Choi, Wonchan Lee,
        Kwangkeun Yi, Philip Wadler.
  - Kmett's type classes versus the world. i.e. global uniqueness of
    type classes. Kmett says he wants both type classes and an ML
    style module system.
  - Investigate modules/type-classes in Agda/Coq/Cayenne.
  - [[http://www.cs.unibo.it/%7Easperti/PAPERS/tphol09.pdf][Unification Hints]]
  - [[http://lambda-the-ultimate.org/node/4865#comment-78251][Comments on Type class implementation by Oleg (LtU)]]
  - http://okmij.org/ftp/Computation/typeclass.html
  - Coq's "First Class Type Classes" [[http://mattam.org/research/publications/First-Class_Type_Classes.pdf][paper]] [[http://mattam.org/research/publications/First-Class_Type_Classes-Gallium-031108.pdf][slides]].

** Demystifying Datatype Generic Programming
  - polytypic programming or whatevers
  - [[http://itu.dk/people/asal/pubs/msc-thesis-report.pdf][The Practical Guide to Levitation]], Ahmad Salim Al-Sibahi M.Sc. Thesis
    - https://github.com/ahmadsalim/MSc-Thesis
  - [[https://personal.cis.strath.ac.uk/conor.mcbride/levitation.pdf][Gentle Art of Levitation]]
  - SYB
  - GHC.Generic - why do people not like this
  - uniplate etc.
  - how does this apply in a dependently typed setting?
  - http://www.andres-loeh.de/ExploringGH.pdf
  - Talk from Andres Löh
    - http://skillsmatter.com/podcast/home/a-haskell-lecture-with-leading-expert-andres-loh
    - http://www.andres-loeh.de/GP-ITB.pdf
  - add datatype generic programming section to PLT website.
  - [[http://dreixel.net/research/pdf/gpif.pdf][Generic Programming with Indexed Functors]], Andres Löh, José Pedro Magalhães
    - port to Idris https://github.com/pbl64k/gpif-idris
  - Andres recommends generics-sop these days. Introduction at https://github.com/kosmikus/SSGEP.

** Demystifying Homotopy Type Theory

  - https://homotopytypetheory.org/book/
  - https://www.cs.cmu.edu/~rwh/courses/hott/
  - https://mdnahas.github.io/doc/Reading_HoTT_in_Coq.pdf
  - [[https://inconsistentuniverse.wordpress.com/2014/02/04/simplicial-sets/][Simplical sets]] (blog series)
  - [[https://inconsistentuniverse.wordpress.com/2014/02/05/thinking-about-the-design-space-of-higher-dimensional-type-theories/][Thinking about the design space of higher dimensional type theories]]
  - Should Toplogy be required:
    - Topology, Second Edition, James R. Munkres

*** Category Theory

  - Dominic Verity introductory talks
    - [[https://vimeo.com/17207564][Part 1]]
    - [[https://youtu.be/yilkBvVDB_w][Part 2]]
  - http://category-theory.mitpress.mit.edu

*** Categorical Logic

  - http://www.cs.man.ac.uk/~pt/Practical-Foundations/html/index.html
  - https://ncatlab.org/nlab/show/Sheaves+in+Geometry+and+Logic
  - https://www.andrew.cmu.edu/user/awodey/catlog/notes/
  - http://www.mathematik.tu-darmstadt.de/~streicher/CTCL.pdf
  - [[http://www.mpi-sws.org/~dreyer/courses/catlogic/jacobs.pdf][Categorical Logic and Type Theory]]
  - [[http://www.edsko.net/tcd/talks/cattheory.pdf][Abstract nonsense for Functional Programmers]]

*** Topos

  - [[https://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories-ebook/dp/B00AKE1VFE?ie=UTF8&me=&ref_=mt_kindle][Conceptual Mathematics]]
  - [[http://arxiv.org/pdf/1012.5647v3.pdf][An information introduction to Topos theory]]
  - https://ncatlab.org/nlab/show/topos
  - http://www.staff.science.uu.nl/~ooste110/syllabi/toposmoeder.pdf
  - [[http://math.ucr.edu/home/baez/topos.html][Topos Theory in a Nutshell]]

** Functional Programming in Scala

  - http://eed3si9n.com/learning-scalaz/
  - [[http://blog.jetbrains.com/scala/2016/04/21/how-to-contribute-to-intellij-scala-plugin/][Contribute to intellij-scala]]

** Focusing

  - https://www.cs.cmu.edu/~fp/courses/oregon-m10/04-focusing.pdf
  - https://www.cs.cmu.edu/~fp/courses/15816-s12/lectures/09-focusing.pdf

** Write an efficient nanopass compiler.
  - https://github.com/sellout/recursion-scheme-talk/blob/master/nanopass-compiler-talk.org

** Investigate strict v non-strict
  - strict/cbv (with at least optional call-by-name) v non-strict/lazy/cb-need
  - with stream transducers, generators (Simple Generators), pipes, conduits, machines, iteratees, Clojures's transducers/reducers etc for stream processing. These work well with strict languages.
    - https://dl.dropboxusercontent.com/u/4588997/Machines.pdf
  - with delimited control for (tree) search.
    - http://okmij.org/ftp/continuations/#reify-search
    - tree search was the defining reason from John Huges Why FP Matters IIRC.
    - isSubstringOf x y = any (isPrefixOf x) (tails y)
      - Cale Gibbard
      - http://lambda-the-ultimate.org/node/1277#comment-14313
      - Noted in FPiS
  - it's all delimited control.
  - perhaps we don't need laziness even for modular list/collection methods mentioned by Lennart Augustsson.
    - http://augustss.blogspot.com.au/2011/05/more-points-for-lazy-evaluation-in.html
#+BEGIN_SRC
  any :: (a -> Bool) -> [a] -> Bool
  any p = or . map p
#+END_SRC
  - take a look at the point of laziness article by Robert Harper.
  - scan FPiS for uses of laziness or call-by-name.
  - Implement this stuff in Idris and/or Scala to try it out.
  - CBPV? http://math.andrej.com/2008/11/23/a-toy-call-by-push-value-language/

** Investigate totality / partiality / Turing-completeness etc.

  - https://personal.cis.strath.ac.uk/conor.mcbride/TotallyFree.pdf
  - http://www.cs.nott.ac.uk/~pszvc/publications/General_Recursion_MSCS_2005.pdf

** Effects
  - implement monad transformers
  - take a look at algebraic effects.
  - Idris 
    - https://eb.host.cs.st-andrews.ac.uk/drafts/effects.pdf
    - [[http://docs.idris-lang.org/en/latest/effects/index.html][Idris Effects Tutorial]]
  - PureScript
    - http://www.purescript.org/learn/eff/
  - Eff
    - http://www.eff-lang.org
  - Frank
    - https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/
    - http://homepages.inf.ed.ac.uk/slindley/papers/frankly-draft-march2014.pdf
  - Koka
  - https://github.com/yallop/effects-bibliography

** Haskell

- Can it be proven that total languages can safely use fusion (because 
  they can evaluated non-strictly)?

*** Swift parser for Haskell

  - sigh, language-swift-quote is stalled because of ambiguities in
    the grammar

*** Turtle

  - Convert the [[http://tldp.org/LDP/abs/html/string-manipulation.html][horrors of Bash]] to the wonders of Turtle Haskell

*** Web frameworks in Haskell.
   - Try out Scotty, Spock, Yesod, Snap, Servant.
     - http://www.yesodweb.com/book/yesod-for-haskellers
   - Write a REST/JSON client in Haskell (Twitter/GitHub client, say).
   - Write a REST/JSON server in Haskell.
   - Write a "sessionless" web app in Haskell.

*** Learn pipes

   - https://ocharles.org.uk/talks/2013-09-18-pipes.pdf
   - https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/Pipes%20tutorial
** Demystifying Advanced Functional Programming
  - recursion schemes
  - Algebra of Programming.
  - notes/slides/courseware on advanced FP techniques

** Demystifying Compilers
  - Develop (literate) code, articles, slides, notes, articles.
  - Writing/blog series on BabyML / BabyIdris:
    - Let noone ever recommend "Let's write a compiler" ever again.
    - Stephen Diehl is doing a very nice job for a Haskell-like
      language so let's stick with CBV and move into DTs.
    - "The essense of compilation" compiling a simple language in the
      smallest possible compiler ([[http://www.timphilipwilliams.com/posts/2014-05-22-the-essence-of-compilation.html][inspiration]]). More than Hutton's Razor!
    - http://jozefg.bitbucket.org/posts/2015-03-24-pcf.html
    - There seem to be a few Min/Mini-ML/NanoML and NanoAgda's about.
    - Also Simply Easy / Simply Easier / PiSigma and pi-forall.
  - Main outline
    - First there's a high-level language (probably interpreter or
      "bytecode" compiler". Basically the "front-end".
      - Type checking.
      - [Parametric] Polymorphism (aka generics).
      - Type inference. Probably HM/ML sweet spot.
    - Second, there's the compiler to native machine code with
      Instruction Selection, Register Allocation, Flow control,
      calling conventions, first-class functions and closure conversion.
      Basically the back-end.
    - Thirdly, there's optimisations like inlining, constant folding,
      copy propagation etc. This should probably be 2nd.
    - Fourthly, there's runtime system considerations:
      - Garbage collection.
  - Another skeleton:
    - Introduction to language design with the BabyML.
    - Lexing/Parsing
    - Semantic Analysis (Type Checking)
    - Simple IL/IR generation
    - Backends
      - Simple IL interpreter/engine + runtime.
      - Compile to native x86 or x86-64 (or x86-64 in with 32 bit pointers).
      - "transpile" to JS.
      - "transpile" to C?
      - "transpile" to Java (pro'ly unnecessary).
      - Compile to JVM (pro'ly unnecessary).
      - Compile to CLR/CLI (pro'ly unnecessary).
  - MinCaml looks great particularly for the middle to backend. Would
    be nice to have polymorphism (i.e. nicer PL) in the front-end though.
  - [[https://www.cs.indiana.edu/~sabry/teaching/b522/s03/][CSCI B522 Programming Language Foundations Amr Sabry (course)]]
    - MinML/NanoML semantics. Be nice to write it up in `org-mode`
      and/or $$\LaTex$$.
    - Also seems to have verifications/proofs in Twelf.
  - [[https://www.seas.upenn.edu/~cis341/current/#lectures][UPenn cis341 Compilers]] Steve Zdancewic. OCaml. Beautiful slides. *****
  - [[https://iu.instructure.com/courses/1517577][SP16 Compilers 11241 Jeremy Siek (course)]]
    - [[https://www.sharelatex.com/project/5637a774990f556d48bab667][course book/notes]]
    - http://github.com/jsiek/Essentials-of-Compilation

** Demystifiying Lexer Generators

   - Would like to be able to generate the lexer from an embedded
     description. Pretty sure that Manuel Chakravarty did work on this
     (I have a note somewhere's).
   - Let's have something like this in Idris (and all the cool PLs).
     At least a Lex like thing.
   - [[http://programatica.cs.pdx.edu/P/hallgren.pdf][This]] lexer for Haskell embedded a lexer generator.
     - Looks like it was used in hssources (is that a Hackage
       project?)
     - Paper says that the regex generator was based on the
       presentation in Appel's Modern Compiler Implementation in ML. 

** Demystifiying Parser Generators

  - I like the approach of [[https://hackage.haskell.org/package/BNFC-meta][BNFC-meta]]. It defines the grammar in the
    language (even if it's via TH). Let's have this in Idris (and the
    cool PLs). At least something like Happy.
  - I know there's supposed to be more general way to parse these days
    than LR and LALR but perhaps they are slow too (if not, embed
    those types of grammars instead!).
  - [[https://github.com/ollef/Earley/][Early]] an embedded Early (context-free) parser combinator library
    in Haskell.
  - Haskell style "layout rule". PKA Landin's offside rule.
    - https://github.com/ghc/ghc/blob/master/compiler/parser/Lexer.x
    - https://michaeldadams.org/papers/layout_parsing/

** Demystifying Automated Deduction
  - aka course notes/slides for Automated Deduction
  - The theorem prover from ML for the Working Programmer.
  - Djinn walkthrough.

** Demystifying Proof Assistants
  - Introduction to Coq.
  - Introduction to Agda.
  - Introduction to Isabelle.
  - Introduction to Twelf.

** Nix or Package all the things

  - Nix for your dotfiles.
  - Nix for your development environment configuration.
  - Nix for your own tools (aka etools at Ephox).
  - Nix for your (proprietary) software products.

** Rational Startup Movement

  - Start writing up "The Rational Startup"
    - Using Haskell for a startup.
    - Rational software tooling.
    - Haskell.
    - PureScript.

** PureScript

  - Port [[https://twitter.com/li_haoyi][Li Haoyi]]'s Scala-JS examples to PureScript.
    - https://gist.github.com/lihaoyi/9443f8e0ecc68d1058ad
    - Idris & Glorious GHCJS.

** Learning Type Theory
  Adapted from https://github.com/type-theory/learn-tt
  - [ ] Textbooks
    - [ ] PFPL
    - [ ] TAPL
    - [ ] ATTAPL
    - [ ] TTFP
    - [ ] PFM [[http://www.paultaylor.eu/%7Ept/prafm/html/index.html][Practical Foundations of Mathematics]] Paul Taylor
    - [ ] SF [[https://www.cis.upenn.edu/~bcpierce/sf/][Software Foundations]]
  - [ ] Proof Assistants
    - [ ] Coq
    - [ ] Agda
    - [ ] Idris
    - [ ] Twelf
  - [ ] Type Theory
    - [ ] The Works of Per Martin-Löf
      - [ ] 1972
      - [ ] 1979
      - [ ] 1984
    - [ ] Programming In Martin-Löf's Type Theory
    - [ ] The Works of John Reynolds
      - [ ] Types, Abstraction and Parametric Polymorphism (Parametricity for System F)
      - [ ] A Logic For Shared Mutable State
      - [ ] Course notes on separation logic
      - [ ] Course notes on denotational semantics
    - [ ] Computational Type Theory
      - [ ] Type Theory and its Meaning Explanations
      - [ ] A Non-Type-Theoretic Definition of Martin-Löf’s Types
      - [ ] Constructing a type system over operational semantics 
	    (Similar to the above, they're helpful to read together)
      - [ ] Equality in Lazy Computation System (of general interest)
      - [ ] Naive Computational Type Theory
      - [ ] Innovations in CTT using NuPRL
      - [ ] Two Lectures on Constructive Type Theory
    - [ ] Homotopy Type Theory
      - [ ] The HoTT book
      - [ ] Student's Notes on HoTT
  - [ ] Proof Theory
    - [ ] Frank Pfenning's Lecture Notes
      - [ ] Constructive Logic
      - [ ] Linear Logic
      - [ ] Modal Logic
  - [ ] Category Theory
    - [ ] Category Theory for Computer Scientists
    - [ ] Category Theory, Awodey
    - [ ] [[http://www.cs.cmu.edu/%7Eedmo/research/notes/intro_categorical_semantics.pdf][Introduction to Categorical Semantics for Proof Theory]] OPLSS
      2015 Ed Morehouse
  - [ ] Other Goodness
    - [ ] [[https://mitpress.mit.edu/books/semantics-programming-languages][Semantics of Programming Languages]], Carl Gunter
    - [ ] OPLSS
      - [ ] 2012
      - [ ] 2013
      - [ ] 2014
      - [ ] 2015

** OPLSS
  - [-] OPLSS
    - [-] 2010
      - [X] Type Theory Foundations — Robert Harper
      - [X] Proof Theory Foundations — Frank Pfenning
      - [ ] Dependently Typed Programming — Conor McBride
      - [ ] Proofs-as-Processes (in CTT) — Robert Constable
      - [ ] Proving a Compiler — Xavier Leroy
      - [X] Software Foundations in Coq — Benjamin Pierce
      - [X] Essential Coq from Scratch — Andrew Tolmach
    - [ ] 2011
    - [ ] 2012
    - [ ] 2013
    - [ ] 2014
    - [ ] 2015
      - [ ] Basic Proof Theory — Frank Pfenning
      - [ ] Introduction to Dependent Type Theory — Robert Harper
      - [ ] Basic Category Theory: Semantics of Proof Theory — Ed Morehouse
      - [ ] Inductive and Inductive-Recursive Definitions in Intuitionistic Type Theory — Peter Dybjer
      - [ ] The Coq Proof Assistant and Its Applications to
        Programming-Language Semantics — Adam Chlipala
      - [ ] Logical Relations — Amal Ahmed
      - [ ] Mark Bickford
      - [ ] Robert Constable
    - [-] 2016
      - [-] Programming Languages Background — Robert Harper and Dan Licata
	- [X] Lecture 1
	- [X] Lecture 2
	- [X] Lecture 3
	- [X] Lecture 4
	- [X] Lecture 5
	- [ ] Lecture 6
	- [ ] Lecture 7
	- [ ] Lecture 8
      - [ ] Category Theory Background — Ed Morehouse
      - [ ] Logical Relations — Patricia Johann
      - [ ] Principles of Type Refinement — Noam Zeilberger
      - [ ] Logical relations/Compiler verification — Amal Ahmed

** Demystifying Isabelle/HOL

  - [[http://homes.soic.indiana.edu/classes/spring2015/csci/b522-jsiek/][CSCI B522 Programming Language Foundations, Jeremy Siek (course)]]

** Writing papers
  - org-mode
  - [[https://github.com/jkitchin/org-ref][org-ref]]
  - https://github.com/vikasrawal/orgpaper/blob/master/orgpapers.org
  - [[https://github.com/kawabata/ox-pandoc][ox-pandoc]]

*** Learn LaTex

 - Produce something (tech report?) with LaTeX. Perhaps via org-mode.

** Reading

  - [[http://gallium.inria.fr/~xleroy/bibrefs/leroy.html][Xavier Leroys publications]]

** Misc

- Find old ADC/Intec shares.
- Fix old Hakyll blog http://timbaumann.info/posts/2013-08-04-hakyll-github-and-travis.html
